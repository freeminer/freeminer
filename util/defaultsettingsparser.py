#!/usr/bin/env python

import re
import sys
import os

__version__ = "1.0.0"

regexpression = "([\"]([^\",]*)[\"])"
source_file = "." + os.sep + "defaultsettings.cpp"
output_file = ".." + os.sep + "freeminer.conf.example"
comment = "//"
dev_comment = "#"
settings_pointer = "settings->setDefault("

def build_header():
	# This is a seperate function, so that we
	# can even use some automatically build header
	# with additional information if needed
	f_header = """# This file is read by default from:
# ../freeminer.conf
# ../../freeminer.conf
# Any other path can be chosen by passing the path as a parameter
# to the program, eg. "freeminer(.exe) --config ../freeminer.conf.example"
#
# By default, all the settings are commented and not functional
# Uncomment settings by removing the preceding '#'.
#
# Further documentation:
# http://wiki.minetest.net/
#
# NOTE: Some of the settings are implemented in Lua
# NOTE 2: This file should be autogenerated and therefore up-to-date
#         One can always refer to the defaultsettings.cpp from this location:
# https://github.com/freeminer/freeminer/blob/master/util/defaultsettings.cpp
"""
	return f_header


def parse_contents(in_fh, out_fh):
	in_fh.seek(0, 0)
	regex_c = re.compile(regexpression)
	line = 0
	while(True):
		tmp = in_fh.readline()
		line += 1
		if tmp == '':
			# reached EOF
			break
		if comment in tmp:
			if settings_pointer in tmp:
				# Only commented setting from the devs, not
				# important for application users
				continue
			out_fh.write('#' + tmp[tmp.find(comment) + 2:])
		elif dev_comment in tmp:
			continue
		elif settings_pointer in tmp:
			# Here we will do a regex search for the settings pattern, and
			# push it to out_fh with a preceding '#'
			matches = regex_c.findall(tmp)
			if len(matches) > 2:
				if "font" in tmp:
					out_fh.write('#' + matches[0][1] + '=' + matches[1][1] + os.sep + matches[2][1] + '\n')
				else:
					print('Warning, multiple settings in one line?')
					print('Line: %i Content:\n%s'%(line, tmp))
					out_fh.write('#' + matches[0][1] + '=' + matches[1][1] + '\n')
			elif len(matches) == 2:
				out_fh.write('#' + matches[0][1] + '=' + matches[1][1] + '\n')
			elif len(matches) == 1:
				out_fh.write('#' + matches[0][1] + '=' + '\n')
	# If we reach this part, the file should be parsed
	# Close the file handles and leave it for now
	in_fh.close()
	out_fh.write('\n')
	out_fh.close()
	return True


def main():
	in_fh = 0
	out_fh = 0
	try:
		in_fh = open(source_file, "r")
	except IOError:
		print("Was not able to open file %s"%(source_file))
		print("Make sure you have the permission to open this file")
		sys.exit(1)
	try:
		out_fh = open(output_file, "w")
	except IOError:
		print("Was not able to open file %s"%(output_file))
		print("Make sure you have the permission to create the file in this directory")
		sys.exit( 2 )
	out_fh.write(build_header())
	if not parse_contents(in_fh, out_fh):
		in_fh.close()
		out_fh.close()
		sys.exit(3)
	# else
	sys.exit(0)

if __name__ == '__main__':
	# Do it the unix way: Be silent until error occurs
	# print("Settings parser v%s"%(__version__))
	main()
